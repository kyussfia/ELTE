A rendszerkatalógus maga is egy adatbázisnak tekinthetõ, amit lekérdezve egyre többet
tudhatunk meg az ORACLE adatbázisban tárolt dolgokról és azok tulajdonságairól.
Elnevezésük: DBA_..., ALL_..., USER_...

Vigyázat !!!
Az alábbiakban ha egy objektumnak vagy egy felhasználónak a neve kisbetûvel 
szerepel a feladat szövegében, az nem jelenti, hogy ez az adatszótárban is kisbetûvel
van tárolva. Pl. orauser - ORAUSER felhasználó, emp - EMP tábla.

Adatbázis objektumok
--------------------
(DBA_OBJECTS)

Kinek a tulajdonában van a DBA_TABLES nevû nézet (illetve a DUAL nevû tábla)?

Kinek a tulajdonában van a DBA_TABLES nevû szinonima (illetve a DUAL nevû)?
(Az iménti két lekérdezés megmagyarázza, hogy miért tudjuk elérni õket.)

Milyen típusú objektumai vannak az orauser nevû felhasználónak az adatbázisban?
 SELECT distinct object_type FROM dba_objects
 WHERE owner='ORAUSER';

Hány különbözõ típusú objektum van nyilvántartva az adatbázisban?
 SELECT count(distinct object_type) FROM dba_objects;

Melyek ezek a típusok?
 SELECT distinct object_type FROM dba_objects;

Kik azok a felhasználók, akiknek több mint 10 féle objektumuk van?

Kik azok a felhasználók, akiknek van triggere és nézete is?

Kik azok a felhasználók, akiknek van nézete, de nincs triggere?
 SELECT distinct owner FROM dba_objects WHERE object_type='VIEW'
  MINUS
 SELECT distinct owner FROM dba_objects WHERE object_type='TRIGGER';

Kik azok a felhasználók, akiknek több mint 40 táblájuk, de maximum 37 indexük van?
 SELECT distinct owner FROM dba_objects WHERE object_type='TABLE'
 GROUP BY owner
 HAVING count(*) > 40
  MINUS
 SELECT distinct owner FROM dba_objects WHERE object_type='INDEX'
 GROUP BY owner
 HAVING count(*) >= 37;

Melyek azok az objektum típusok, amelyek tényleges tárolást igényelnek, vagyis
tartoznak hozzájuk adatblokkok? (A többinek csak a definíciója tárolódik adatszótárban)

Melyek azok az objektum típusok, amelyek nem igényelnek tényleges tárolást, vagyis nem
tartoznak hozzájuk adatblokkok? (Ezeknek csak a definíciója tárolódik adatszótárban)
Az utóbbi két lekérdezés metszete nem üres. Vajon miért? -> lásd majd partícionálás


Táblák oszlopai
---------------
(DBA_TAB_COLUMNS)

Hány oszlopa van a nikovits.emp táblának?

Milyen típusú a nikovits.emp tábla 6. oszlopa?

Adjuk meg azoknak a tábláknak a tulajdonosát és nevét, amelyeknek van 'Z' betûvel 
kezdõdõ oszlopa.

Adjuk meg azoknak a tábláknak a nevét, amelyeknek legalább 8 darab dátum tipusú oszlopa van.
 SELECT owner, table_name FROM dba_tab_columns
 WHERE data_type='DATE'
 GROUP BY owner, table_name
 HAVING count(*) >= 8;

Adjuk meg azoknak a tábláknak a nevét, amelyeknek 1. es 4. oszlopa is
VARCHAR2 tipusú.
 SELECT owner, table_name FROM dba_tab_columns
 WHERE column_id=1 AND data_type='CHAR'
  INTERSECT
 SELECT owner, table_name FROM dba_tab_columns
 WHERE column_id=4 AND data_type='CHAR';

Írjunk meg egy plsql procedúrát, amelyik a paraméterül kapott karakterlánc alapján 
kiírja azoknak a tábláknak a nevét és tulajdonosát, amelyek az adott karakterlánccal 
kezdõdnek. (Ha a paraméter kisbetûs, akkor is mûködjön a procedúra!)
     PROCEDURE table_print(p_kar VARCHAR2) 
A fenti procedúra segítségével írjuk ki a Z betûvel kezdõdõ táblák nevét és tulajdonosát.

CREATE OR REPLACE PROCEDURE table_print(p_kar VARCHAR2) is
  CURSOR curs1 IS 
  select owner,table_name from dba_tables
  where upper(table_name) like upper(p_kar)||'%';
  rec curs1%ROWTYPE;
BEGIN
  OPEN curs1;
  LOOP
    FETCH curs1 INTO rec;
    EXIT WHEN curs1%NOTFOUND;
    dbms_output.put_line(rec.owner||' - '||rec.table_name);
  END LOOP;
  CLOSE curs1;
END;
/
Test:
set serveroutput on
call table_print('z');


HÁZI FELADAT (kicsit több idõt igényel, mint a gyakorlaton megoldandók)
------------
Írjunk meg egy plsql procedúrát, amelyik a paraméterül kapott táblára kiírja 
az õt létrehozó CREATE TABLE utasítást. 
   PROCEDURE cr_tab(p_owner VARCHAR2, p_tabla VARCHAR2) 
Elég ha az oszlopok típusát és DEFAULT értékeit kíírja, és elég ha a következõ típusú 
oszlopokra mûködik.
 CHAR, VARCHAR2, NCHAR, NVARCHAR2, BLOB, CLOB, NCLOB, NUMBER, FLOAT, BINARY_FLOAT, DATE, ROWID

Teszteljük a procedúrát az alábbi táblával.
CREATE TABLE tipus_proba(c10 CHAR(10) DEFAULT 'bubu', vc20 VARCHAR2(20), nc10 NCHAR(10), 
  nvc15 NVARCHAR2(15), blo BLOB, clo CLOB, nclo NCLOB, num NUMBER, num10_2 NUMBER(10,2), 
  num10 NUMBER(10) DEFAULT 100, flo FLOAT, bin_flo binary_float DEFAULT '2e+38', 
  bin_doub binary_double DEFAULT 2e+40,
  dat DATE DEFAULT TO_DATE('2007.01.01', 'yyyy.mm.dd'), rid ROWID);






